
6-8-18 Code Review Comments

	- Used an IDictionary appropriately, since order is important, but not an IList since we're normally querying by key vs. value, and not IEnumerable or IQueryable because order is important. 
	- LayoutDescriptor.fields is private because we wanted to manage appending entries ourselves, given the calculations and dependencies that go along with it.
	- Used a generic for the model, so that’s decoupled nicely. 
		- If the entity we’re parsing changes, FixedLayoutParser class does not change.
		- If business needs change, no changes needed to FixedlayoutParser. 
	- Reviewed changes required to allow for chained expression methods from an existing AppendField method.
		e.g. LayoutDescriptor<TTarget> AppendField<TProperty>(Expression<Func<TTarget, TProperty>> expression, int fieldLength);


6-8-18
      Added IFlatFileLayoutDescriptor interface and documentation.
      Moved documentation to interface (vs. implementation). Only implementation specific comments remain.
      Refactored unit test naming and added new class for Type Converter Tests

6-11-18
      Thought about support for non-string types and type converters

      To do the above, need to have a working or mocked parser. Started adding a dummy flat file parser for now.
      Added new method to IFlatFileLayoutDescriptor interface to get ordered fields. Could return collection of
      all fields, and order in parser, OR order in LayoutDescriptor. Chose to order in LayoutDescriptor, since
      sorting depends on the implementation of fields (currently Dictionary<int, FixedFieldSetting>).

6-12-18
      Resumed on DummyFixedWidthFileParser. Use this in unit test for the type converter, and test converting id
      from string to int. Can either use reflection in the dummy class, or hardcode just for the primitive type.
      probably want to hardcode if type is PrimitiveTypes, else not implemented exception. 

6-13-18
      Implemented basic ParseFile method in FixedWidthFileParser
      Created unit tests
          - Created test model for strings and primitive types
          - Generated fixed width test file (StringTest.dat)
          - Overrode equals method and equality operators
          - Successfully implemented and tested parsing into string models
  
6-13-18 - Code Review Comments
 
1. Simplify error handling. 
     - What's in place is good if handling each exception differently (e.g. retrying on IO failure, 
       vs. something different for FileNotFound). Simply bubbling up a different error message for each one
       is not a good reason. Also, because inner exception isn't set, this actually reduces the information 
       sent up. Could either add custom exceptions, or remove all try  / catches. The purpose of this exercise
       is practicing OOP principles and SOLID practices, so going to skip the exception handling for now.
		- Done (Removed)
2. Use a generic as the return type in IFixedWidthFileParser
     - In 'IFixedWidthFileParser', change 'IDictionary<int, TEntity>' to a generic return type.
		- Done
3. If re-throwing an exception, set the inner exception.
     - Likely removing all error handling for now (per #1), so this may be a non-issue
		- Done (removed error handling for now)
4. ParseFile should return a generic (similar to #2).
		- Done, returned TFile
5. I implemented one or more interfaces. Use these interfaces as the types now instead of concrete types
		- Done
6. Repeat above for all complex types (e.g. IList instead of list)
     - While I'm at it, I want to think through data structures more. e.g. ICollection vs. IDictionary for
       the entities being returned from ParseFile
	 - Update List to IList, Dictionary to IDictionary, etc...
	 - Level set on data structures. Think through the types used, and if each one is a good fit. Why or why not? 
		- IList is used once in GetOrderedFields
			- GetOrderedFields is invoked once in GetModelFromLine.
				- Nowhere is Add / Remove needed. This should be a collection instead. IEnumerable wouldn't honor the
				  custom order. ICollection honors the custom order, IList also does, but we don't need the extras. 
				- In GetOrderedFields, could call Enumerable.ToList() or cast to ICollection<T>. ToList creates a  
				  cached copy, so chose the cast instead. 
					- Switched to ToList, the cast generated an InvalidCastException. Can't cast a
					  WhereSelectEnumerableIterator to ICollection<IFixedFieldSetting>
		- No more lists are used anywhere in solution. 

6-14-18
     - Removed all Try / Catches.
     - Documented a few pre-conditions that should be checked for instead.
     - Updated FixedWidthFileParser and the interface to use a generic for the return type of ParseFile
     - Removed 'Peek' from ParseFile implementation
     - Started updating unit tests from Dictionary to Collection for return type from ParseFile

6-19-18
	- Documentation
	- Updated to depend on interfaces, not implementations. (Updated concrete types to interfaces where possible in FixedWidthFileParser, LayoutDescriptor, and unit tests)
		- e.g. LayoutDescriptor field in FixedWidthFileParser, is now IFlatFileLayoutDescriptor
		- Changed types from FixedFieldSetting to IFixedFieldSetting (except where instantiating). Maybe ninject down the road? 

6-26-18
	- Thought through data structures in solution. 
	- Only one list is used, changed this to a collection in GetOrderedFields, since we only care about the order.
	  No list operations (Add / Remove, etc...) are required. 

6-27-18
	- Cleaned up unit tests
	- Started thinking through type converter api
		- Would like built in converters for primitive types, and custom converter exposed for mapping to complex objects
		- On IFlatFileLayoutDescriptor, could add "AsBool" to be used after AppendField. 
			- e.g.  IFlatFileLayoutDescriptor<TTarget> AsBool<TProperty>();
			- Nothing tells me that this is for the previously appended field though. Probably want to add the
			  converter in AppendField extension method.
			- If option is exposed, do we pass an enum for which basic type we try converting to, and also accept an 
			  expression for a custom converter? 
		- Thinking .WithTypeConverter is a better option and more readable. Perhaps an api like the following
			- .AppendField(x => x.id, fieldLength).WithTypeConverter<StringConverter>()
			- signature: IFlatFileLayoutDescriptor<TTarget> WithTypeConverter<TTypeConverter>();
	- Polyfilled C# 6 safe equals method in DummyStringModel. Unit tests pass, can now build in C# 6 / VS 2015


6-27-18 - Code Review Comments
	1. Leave ParseFile's return type as ICollection. Don't switch to IEnumerable, since we use the "Add" method internally. 
		- Remove class level generic TFile
		- Just return an ICollection (already in place) of type TEntity in ParseFile
			- e.g. Interface for ParseFile is simply ICollection<T> ParseFile. Not TFile (that allows ICollection to be any type via a second generic)
		- DONE
	2. ParseFile implementation is good. 
		- +1 on reading line by line via the stream. ReadLine from stream preferable over ReadAllLines, so whole file isn't in memory
	3. Cache OrderedFields either in LayoutDescriptor, or in a variable above the loop in GetModelFromLine
		- DONE
			- Thought best to cache in LayoutDescriptor, in so cached for any others calls to get ordered fields going forward. 
			- Saved as class level field. Marked this dirty in the Add method, so recalculated after field is appended
*		- LEE - should this be a public property instead of a method? 
	4. Remove tentative WithLayoutDescriptor extension method in FlatFileLayoutDescriptor. 
		- Implement type converter by convention for primitive types, then go from there w/ the api. 
			- ********* RESUME HERE ********* 
			- Implement convention based type converter for primitive types. Use built in parse or tryparse methods. 
			  Use type in existing PropertyInfo, don't make user pass in the type a second time. 
				- Remember, DateTime is NOT a primitive type :)
			- As a rule of thumb, favor CONVENTION over CONFIGURATION.

6-28-81
	- Refactored unit tests. 
	- Removed virtual method calls from constructor (ParserTestBase)
	- Shared patterns and parsing for string tests and primitive type tests

7-2-18
	- Implemented default TypeConverter for primitive types w/ reflection and built in Parse method.
	- Implemented boolean specific type converter to account for 0 and 1, and uppercase True / False strings. 
	- Implemented unit tests for boolean type converter and number of rows matching input file

7-3-18
	- Changed ParseFile to right trim string fields. This should eventually be configurable. 
